---
title: "An Introduction to STEAM"
author: UPDATE AUTHORS!!!
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{An Introduction to STEAM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(STEAM)
```

# Introduction

# Installation

## Bioconductor

## GitHub

# Required Data Format (come up with better name?)

Grinde et al. (2019) proposed two approaches for estimating genome-wide significance thresholds for admixture mapping studies: Analytic Approximation (Section 4.2) and Test Statistic Simulation (Section 4.3). 

To run either approach, we first need to:

**Step 1:** Create a `map` file containing, at minimum, the chromosome number and genetic position (in centimorgans) of each marker being tested.
   
   * **NOTE:** If you inferred local ancestry using a program that performs calling within windows (e.g., RFMix), we recommend that you include just a single marker per window in this map file.
   
Here is an example of a map file, `example_map`, available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data):
```{r}
## first 6 rows of example_map ##
head(example_map)
```

**Step 2:** Estimate the admixture proportions for each individual and store them in an `n`-by-`K` matrix, where `n` is the number of admixed individuals and `K` is the number of ancestral populations.
   
   * There are various ways to calculate these proportions, one of which is to calculate the genome-wide average local ancestry for each individual.
   
Below is an example of a matrix of admixture proportions, `example_props`, available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data). This matrix contains the admixture proportions for `n = 1000` admixed individuals and `K = 2` ancestral populations:
```{r}
head(example_props)
```

Similarly, `example_props_K3` in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data) is an example admixture proportions matrix for `n = 1000` admixed individuals and `K = 3` ancestral populations:
```{r}
head(example_props_K3)
```


**Step 3:** Estimate g, the number of generations since admixture.
   
   * We recommend that you use STEAM for this step. **NOTE:** Using this approach requires that you calculate the observed correlation of local ancestry at pairs of loci in your data. For more details, please see Section 4.1 below.

# Main Functions

The STEAM package contains the following main functions:

| Function | Description |
|----------|----------|
| `get_g` | estimate the number of generations since admixture |
| `get_thresh_analytic` | for K = 2 populations, compute genome-wide significance threshold for admixture mapping |
| `get_thresh_simstat` | for K = 2 or K = 3 populations, compute genome-wide significance threshold for admixture mapping |

`g`, the number of generations since admixture, is a required parameter for both `get_thresh_analytic` and `get_thresh_simstat`. `g` can be quickly estimated using the `get_g` function using the observed correlation of local ancestry at pairs of loci in the data. This method is described in Section 4.1 below.

## Estimating g (get_g)

The theoretical results in Grinde et al. (2019) demonstrate that the number of generations since admixture controls the rate of decay of local ancestry correlation curves in admixed populations. *Lemma 1* provides a closed form expression for the expected correlation of local ancestry at a pair of loci, which depends on the recombination fraction between those loci, the distribution of admixture proportions, and the generations since admixture. We use this result to motivate a non-linear least squares procedure to estimate the number of generations since admixture (`g`) from observed local ancestry correlation. 

Estimating `g` from our observed data---rather than relying on estimates from external genetic or historical studies---allows us to appropriately capture the correlation structure in our own data, which is critical for our multiple testing procedures.

**To use STEAM to estimate `g`, we must first calculate the observed correlation of local ancestry at pairs of loci in our data.** Calculating this correlation for all possible pairs of loci is not necessary; using a representative, thinned subset of markers will suffice. However, correlation should be calculated for all possible pairs of ancestral components:

* In an admixed population with 2 ancestral populations (e.g., African (AFR), European (EUR)), there are three possible pairs of ancestral components (AFR at both loci, EUR at both loci, AFR at one locus and EUR at the other locus).

* In an admixed population with 3 ancestral populations (e.g., African, European, Native American (NAM)), there are six possible pairs of ancestral components (AFR at both loci, EUR at both loci, NAM at both loci, AFR at one and EUR at the other, AFR at one and NAM at the other, EUR at one and NAM at the other).

Store this local ancestry correlation in a data frame with three columns, as in the following examples (available in the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data)):

```{r}
## 2 ancestral populations ##
head(example_corr)
```

```{r}
## 3 ancestral populations ##
head(example_corr_K3)
```

### Calculating Observed Local Ancestry Correlation using STEAM

You are free to calculate this local ancestry correlation however you please. One option (if you are studying an admixed population with `K = 3` ancestral populations) is to use the functions `get_corr_chr` and `combine_corr_chr` contained in this package:

**Step 1:** Convert local ancestry calls into SeqArray GDS files, with one file per ancestral population and chromosome (i.e., 'chr22_afr.gds' contains local ancestry calls for chromosome 22, where alleles are coded such that 1 = allele inherited from African ancestors, 0 = allele inherited from some other ancestral population).

* **NOTE:** if you first convert your local ancestry calls into VCF files, with one file per chromosome and ancestral population, then you can use `vcf2gds.py` in the [UW GAC TOPMed analysis pipeline](https://github.com/UW-GAC/analysis_pipeline) to convert to GDS files.

**Step 2:** Run `get_corr_chr` for each chromosome:

```{r eval = FALSE}
# set up list to store results
corr.list <- list()

# loop through chromosomes
# NOTE: we recommend that each chromosome be analyzed separately (e.g., on 
# distinct compute nodes) and results saved, then combined later, rather 
# than analyzing all chromosomes in a single R session
for(i in 1:22){
  # set up file names
  afr.gds <- paste0('chr', i, '_afr.gds')
  eur.gds <- paste0('chr', i, '_eur.gds')
  nam.gds <- paste0('chr', i, '_nam.gds')
  # run get_corr_chr
  corr.list[[i]] <- get_corr_chr(chrom = i, map = example_map, 
        pop1.gds = afr.gds, pop2.gds = eur.gds, pop3.gds = nam.gds)
  # print update
  cat('done with chromosome', i, '\n')
}
```

**Step 3:** Run `combine_corr_chr` to combine results across all chromosomes and store as a data frame in the desired format:

```{r eval = FALSE}
# combine results across chromosomes
corr_K3 <- combine_corr_chr(corr.list)
```

This data frame should include three columns, named `theta`, `corr`, and `anc` (column order does not matter, but the column names do!):

* `theta`: recombination fraction between loci
* `corr`: correlation between those local ancestry components at that pair of loci
* `anc`: indices of ancestral compoments being compared at the two loci (e.g., `1_1`, `1_2`)

### Using `get_g`

Once we have this local ancestry correlation, we use non-linear least squares to estimate the value of `g` that provides the best fit to the equation $\text{Corr} = a + b \times (1-\theta)^g$ (see Grinde et al. (2019) for more details):

```{r}
## 2 ancestral populations ##
get_g(example_corr)
```

```{r}
## 3 ancestral populations ##
get_g(example_corr_K3)
```

**NOTE:** in these examples, we simulated local ancestry correlation for admixed populations with `g = 6` (2 ancestral populations) and `g = 10` (3 ancestral populations). In both cases, the estimated g turns out very close to the truth: 5.97 and 9.96, respectively.

## Analytic Approximation (get_thresh_analytic)

For an admixture mapping study in an admixed population with **two ancestral populations** (e.g., African Americans), we can use either approach (Analytic Approximation or Test Statistic Simulation) to estimate genome-wide significance threshold for our study. The analytic approximation approach is the faster of the two options.

**Step 1:** Suppose we have markers spaced every 0.2 cM across 22 chromosomes. We store the information about genetic position and chromosome for each marker in a data frame called `example_map`:

```{r}
head(example_map)
```

More information about obtaining a `map` data frame can be found in **Step 1** of Section 3: Required Data Format. The example data frame `example_map` can be downloaded from the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data).

**Step 2:** Use STEAM to approximate `g`, the number of generations since admixture. STEAM estimates `g` using the correlation of local ancestry in the data for each pair of loci and ancestral components. The process to obtain `g` is described above in Section 4.1: Estimating g (get_g). 

**Step 3:** We are now ready to estimate our genome-wide significance threshold. We wish to estimate the *p*-value threshold which will control the family-wise error rate for this study at the 0.05 level.

Our two ancestral population example data, `example_corr` (used in the `get_g` function) has a `g` value of 6.

To implement the analytic approximation approach, use the following command. By default, the command will return the *p*-value threshold:

```{r}
get_thresh_analytic(g = 6, map = example_map)
```

`get_thresh_analytic` can also return the test statistic threshold with the following command:

```{r}
get_thresh_analytic(g = 6, map = example_map, type = "stat")
```

The default family-wise error rate used for `get_thresh_analytic` is 0.05. This can be changed using the `alpha` parameter. The following code changes the desired family-wise error rate to 0.01:

```{r}
get_thresh_analytic(g = 6, map = example_map, alpha = 0.01)
```

## Test Statistic Simulation (get_thresh_simstat)

For an admixture mapping study in an admixed population with **two ancestral populations** (e.g., African Americans) **or three ancestral populations** (e.g., Latinx/Hispanic Americans), we can use the Test Statistic Simulation approach to estimate the genome-wide significance threshold for our study. Additionally, the 95% confidence interval for the test statistic simulated significance threshold will also be returned. See Grinde et al. (2019) for more details on the methods and motivation for this approach.

If your population has **two ancestral populations**, the `get_thresh_analytic` function is a faster method to estimate the significance threshold. See Section 4.2: Analytic Approximation (get_thresh_analytic) above for more details. However, running `get_thresh_simstat` with two ancestral populations will still work and return a significance threshold and 95% confidence interval.

If your population has **three ancestral populations**, you must use the `get_thresh_simstat` function to estimate the significance threshold. `get_thresh_analytic` will **not** work with these populations. 

**Step 1:** Suppose we have markers spaced every 0.2 cM across 22 chromosomes. We store the information about genetic position and chromosome for each marker in a data frame called `example_map`:

```{r}
head(example_map)
```

More information about obtaining a `map` data frame can be found in **Step 1** of Section 3: Required Data Format. The example data frame `example_map` can be downloaded from the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data).

**Step 2:** Suppose as well that the individuals in our sample have admixture proportions that are uniformly distributed from 0 to 1. We store these proportions in a data frame called `example_props`:

```{r}
## two ancestral populations ##
head(example_props)
```

```{r}
## three ancestral populations ##
head(example_props_K3)
```

More information about obtaining a `props` data frame can be found in **Step 2** of Section 3: Required Data Format. The example data frames `example_props` and `example_props_K3` can be downloaded from the [STEAM GitHub repository](https://github.com/GrindeLab/STEAM/tree/main/data).

**Step 3:** Use STEAM to approximate `g`, the number of generations since admixture. STEAM estimates `g` using the correlation of local ancestry in the data for each pair of loci and ancestral components. The process to obtain `g` is described above in Section 4.1: Estimating g (get_g).

**Step 4:** We are now ready to estimate our genome-wide significance threshold. We wish to estimate the *p*-value threshold which will control the family-wise error rate for this study at the 0.05 level.

Our two ancestral population example data, `example_corr` (used in the `get_g` function) has a `g` value of 6. Our three ancestral population example data, `example_corr_K3` (used in the `get_g` function) has a `g` value of 10.

`get_thresh_simstat` has the following arguments that can be adjusted to fit the needs of your study:

* `nreps`: the number of repetitions for the simulation study (default value is 10,000)
* `type`: the type of threshold that is returned, "pval" for *p*-value or "stat" for test statistic (default value is "pval")
* `alpha`: the level for family-wise error rate control (default value is 0.05)

To implement the test statistic simulation approach for `K = 2` ancestral populations at the 0.05 level, use the following commands. By default, the command will return the *p*-value threshold:

```{r}
## two ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 6, map = example_map, props = example_props, nreps = 50)
```

For `K = 3` ancestral populations, the command is similar:

```{r}
## three ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 10, map = example_map, props = example_props_K3, 
                   nreps = 50)
```

**Note:** Computation time increases with the number of replications, so for the purposes of this example we choose a small number of reps. In practice, we recommend using a much larger number number of replications (the STEAM default is 10,000 reps).

To return the test statistic threshold rather than the *p*-value threshold, use the following commands:

```{r}
## two ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 6, map = example_map, props = example_props, 
                   nreps = 50, type = "stat")
```
```{r}
## three ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 10, map = example_map, props = example_props_K3, 
                   nreps = 50, type = "stat")
```

To change the desired family-wise error rate, use the following commands:

```{r}
## two ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 6, map = example_map, props = example_props, 
                   nreps = 50, alpha = 0.01)
```

```{r}
## three ancestral populations ##
set.seed(1) # set seed for reproducibility
get_thresh_simstat(g = 10, map = example_map, props = example_props_K3, 
                   nreps = 50, alpha = 0.01)
```

> **WHAT DOES THE CONFIDENCE INTERVAL MEAN NOW? ASK KELSEY!**

**Note:** the thresholds for three ancestral populations are more stringent than the thresholds for ancestral populations. This reflects the increased number of hypothesis tests being performed when `K = 3` as well as the different distributions of admixture proportions in the two populations.

# Session Info

```{r}
sessionInfo()
```


# References

